/**
 * Observability Integration
 * 
 * PHASE 4: Observability, Attribution & Replay
 * 
 * Integrates observability hooks into governance system.
 * This module adds logging WITHOUT modifying execution logic.
 */

import { EventLog, EventType, CapitalCheckEvent, RegimeCheckEvent, PermissionCheckEvent, RiskCheckEvent, TradeExecutedEvent, TradeBlockedEvent, SystemModeChangeEvent, StrategyStateChangeEvent, RegimeDetectedEvent, RiskBudgetCheckEvent, RiskBudgetScalingEvent, RiskBudgetDecayEvent, RiskBudgetRecoveryEvent, RiskBudgetAllocationEvent } from './event_log';
import { CapitalGateResult } from '../capital/capital_gate';
import { RegimeGateResult } from '../regime_gate';
import { PermissionResult } from '../permission_gate';
import { TradeRequest, TradeResult } from '../../src/services/riskGovernor';
import { MarketRegime } from '../regime_detector';

/**
 * Observability Hooks
 * 
 * Adds event logging to governance operations without modifying logic.
 */
export class ObservabilityHooks {
  private eventLog: EventLog;

  constructor(eventLog: EventLog) {
    this.eventLog = eventLog;
  }

  /**
   * Log capital check event
   * 
   * PHASE 7: Supports account-scoped events
   */
  logCapitalCheck(
    strategyId: string,
    tradeValue: number,
    result: CapitalGateResult,
    systemMode: string,
    accountId?: string
  ): void {
    const event: CapitalCheckEvent = {
      eventId: '', // Will be generated by eventLog
      timestamp: new Date(),
      eventType: EventType.CAPITAL_CHECK,
      accountId, // PHASE 7: Account-scoped
      strategyId,
      systemMode,
      requestedAmount: tradeValue,
      allocatedCapital: result.allocatedCapital,
      allowed: result.allowed,
      reason: result.reason || 'Capital check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log regime check event
   */
  logRegimeCheck(
    strategyId: string,
    symbol: string,
    result: RegimeGateResult,
    systemMode: string
  ): void {
    const event: RegimeCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.REGIME_CHECK,
      strategyId,
      systemMode,
      currentRegime: result.regime || 'UNKNOWN',
      allowedRegimes: [], // Would need to get from strategy metadata
      allowed: result.allowed,
      reason: result.reason || 'Regime check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log permission check event
   */
  logPermissionCheck(
    strategyId: string,
    result: PermissionResult,
    systemMode: string
  ): void {
    const event: PermissionCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.PERMISSION_CHECK,
      strategyId,
      systemMode,
      tradingAllowed: result.allowed,
      allowed: result.allowed,
      reason: result.reason || 'Permission check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log risk check event
   */
  logRiskCheck(
    strategyId: string,
    allowed: boolean,
    riskState: string,
    drawdown: number,
    reason: string,
    systemMode: string
  ): void {
    const event: RiskCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_CHECK,
      strategyId,
      systemMode,
      riskState,
      drawdown,
      allowed,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log trade executed event
   * 
   * PHASE 7: Supports account-scoped events
   */
  logTradeExecuted(
    request: TradeRequest,
    result: TradeResult,
    systemMode: string,
    regime?: MarketRegime,
    regimeConfidence?: number,
    accountId?: string
  ): void {
    const event: TradeExecutedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.TRADE_EXECUTED,
      accountId, // PHASE 7: Account-scoped
      strategyId: request.strategy,
      systemMode,
      regime: regime?.toString(),
      regimeConfidence,
      pair: request.pair,
      action: request.action,
      amount: request.amount,
      price: request.price,
      orderId: result.orderId,
      executedValue: result.executedValue || request.estimatedValue,
      reason: 'Trade executed successfully',
      metadata: {
        pnl: result.pnl,
        slippage: 0 // Would be calculated if available
      }
    };

    this.eventLog.append(event);
  }

  /**
   * Log trade blocked event
   * 
   * PHASE 7: Supports account-scoped events
   */
  logTradeBlocked(
    request: TradeRequest,
    blockingLayer: 'CAPITAL' | 'REGIME' | 'PERMISSION' | 'RISK',
    reason: string,
    systemMode: string,
    regime?: MarketRegime,
    regimeConfidence?: number,
    accountId?: string
  ): void {
    const event: TradeBlockedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.TRADE_BLOCKED,
      accountId, // PHASE 7: Account-scoped
      strategyId: request.strategy,
      systemMode,
      regime: regime?.toString(),
      regimeConfidence,
      pair: request.pair,
      blockingLayer,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log system mode change
   */
  logSystemModeChange(
    previousMode: string,
    newMode: string,
    reason: string
  ): void {
    const event: SystemModeChangeEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.SYSTEM_MODE_CHANGE,
      previousMode,
      newMode,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log strategy state change
   */
  logStrategyStateChange(
    strategyId: string,
    previousState: string,
    newState: string,
    reason: string,
    systemMode: string
  ): void {
    const event: StrategyStateChangeEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.STRATEGY_STATE_CHANGE,
      strategyId,
      systemMode,
      previousState,
      newState,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log regime detection
   */
  logRegimeDetected(
    symbol: string,
    regime: MarketRegime,
    confidence: number,
    metrics: {
      realizedVolatility: number;
      volatilityExpansion: number;
      trendStrength: number;
      correlationStability: number;
    },
    systemMode: string
  ): void {
    const event: RegimeDetectedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.REGIME_DETECTED,
      systemMode,
      symbol,
      regime: regime.toString(),
      confidence,
      metrics,
      reason: `Regime detected: ${regime} (${(confidence * 100).toFixed(0)}% confidence)`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget check
   */
  logRiskBudgetCheck(
    accountId: string,
    strategyId: string,
    requestedRiskPct: number,
    allocatedRiskPct: number,
    effectiveRiskPct: number,
    allowed: boolean,
    reason: string,
    systemMode: string
  ): void {
    const event: RiskBudgetCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_CHECK,
      accountId,
      strategyId,
      systemMode,
      requestedRiskPct,
      allocatedRiskPct,
      effectiveRiskPct,
      allowed,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget regime scaling
   */
  logRiskBudgetScaling(
    accountId: string,
    regime: string,
    confidence: number,
    previousScalingFactor: number,
    newScalingFactor: number,
    systemMode: string
  ): void {
    const event: RiskBudgetScalingEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_SCALING,
      accountId,
      systemMode,
      regime,
      confidence,
      previousScalingFactor,
      newScalingFactor,
      reason: `Regime scaling: ${regime} (${(confidence * 100).toFixed(0)}% confidence) → ${previousScalingFactor.toFixed(3)} → ${newScalingFactor.toFixed(3)}`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget decay
   */
  logRiskBudgetDecay(
    accountId: string,
    drawdownPct: number,
    penaltyPct: number,
    previousRiskPct: number,
    newRiskPct: number,
    systemMode: string
  ): void {
    const event: RiskBudgetDecayEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_DECAY,
      accountId,
      systemMode,
      drawdownPct,
      penaltyPct,
      previousRiskPct,
      newRiskPct,
      reason: `Drawdown penalty: ${drawdownPct.toFixed(2)}% drawdown → ${penaltyPct.toFixed(2)}% penalty → ${previousRiskPct.toFixed(2)}% → ${newRiskPct.toFixed(2)}% risk`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget recovery
   */
  logRiskBudgetRecovery(
    accountId: string,
    daysSinceDrawdown: number,
    recoveryPct: number,
    previousRiskPct: number,
    newRiskPct: number,
    systemMode: string
  ): void {
    const event: RiskBudgetRecoveryEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_RECOVERY,
      accountId,
      systemMode,
      daysSinceDrawdown,
      recoveryPct,
      previousRiskPct,
      newRiskPct,
      reason: `Recovery: ${daysSinceDrawdown} days → ${recoveryPct.toFixed(2)}% recovery → ${previousRiskPct.toFixed(2)}% → ${newRiskPct.toFixed(2)}% risk`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget allocation change
   */
  logRiskBudgetAllocation(
    accountId: string,
    strategyId: string,
    allocatedRiskPct: number,
    weight: number,
    performanceScore: number,
    systemMode: string
  ): void {
    const event: RiskBudgetAllocationEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_ALLOCATION,
      accountId,
      strategyId,
      systemMode,
      allocatedRiskPct,
      weight,
      performanceScore,
      reason: `Strategy ${strategyId} allocated ${allocatedRiskPct.toFixed(2)}% risk (weight: ${weight.toFixed(3)}, score: ${performanceScore.toFixed(3)})`
    };

    this.eventLog.append(event);
  }
}

