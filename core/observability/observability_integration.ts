/**
 * Observability Integration
 * 
 * PHASE 4: Observability, Attribution & Replay
 * 
 * Integrates observability hooks into governance system.
 * This module adds logging WITHOUT modifying execution logic.
 */

import { EventLog, EventType, CapitalCheckEvent, RegimeCheckEvent, PermissionCheckEvent, RiskCheckEvent, TradeExecutedEvent, TradeBlockedEvent, SystemModeChangeEvent, StrategyStateChangeEvent, RegimeDetectedEvent, RiskBudgetCheckEvent, RiskBudgetScalingEvent, RiskBudgetDecayEvent, RiskBudgetRecoveryEvent, RiskBudgetAllocationEvent, ShadowTradeEvaluatedEvent, ShadowParityMetricEvent, ConfidenceGateBlockedEvent } from './event_log';
import { CapitalGateResult } from '../capital/capital_gate';
import { RegimeGateResult } from '../regime_gate';
import { PermissionResult } from '../permission_gate';
import { TradeRequest, TradeResult } from '../../src/services/riskGovernor';
import { MarketRegime } from '../regime_detector';

/**
 * Observability Hooks
 * 
 * Adds event logging to governance operations without modifying logic.
 */
export class ObservabilityHooks {
  private eventLog: EventLog;

  constructor(eventLog: EventLog) {
    this.eventLog = eventLog;
  }

  /**
   * Log capital check event
   * 
   * PHASE 7: Supports account-scoped events
   */
  logCapitalCheck(
    strategyId: string,
    tradeValue: number,
    result: CapitalGateResult,
    systemMode: string,
    accountId?: string
  ): void {
    const event: CapitalCheckEvent = {
      eventId: '', // Will be generated by eventLog
      timestamp: new Date(),
      eventType: EventType.CAPITAL_CHECK,
      accountId, // PHASE 7: Account-scoped
      strategyId,
      systemMode,
      requestedAmount: tradeValue,
      allocatedCapital: result.allocatedCapital,
      allowed: result.allowed,
      reason: result.reason || 'Capital check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log regime check event
   */
  logRegimeCheck(
    strategyId: string,
    symbol: string,
    result: RegimeGateResult,
    systemMode: string
  ): void {
    const event: RegimeCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.REGIME_CHECK,
      strategyId,
      systemMode,
      currentRegime: result.regime || 'UNKNOWN',
      allowedRegimes: [], // Would need to get from strategy metadata
      allowed: result.allowed,
      reason: result.reason || 'Regime check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log permission check event
   */
  logPermissionCheck(
    strategyId: string,
    result: PermissionResult,
    systemMode: string
  ): void {
    const event: PermissionCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.PERMISSION_CHECK,
      strategyId,
      systemMode,
      tradingAllowed: result.allowed,
      allowed: result.allowed,
      reason: result.reason || 'Permission check completed'
    };

    this.eventLog.append(event);
  }

  /**
   * Log risk check event
   */
  logRiskCheck(
    strategyId: string,
    allowed: boolean,
    riskState: string,
    drawdown: number,
    reason: string,
    systemMode: string
  ): void {
    const event: RiskCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_CHECK,
      strategyId,
      systemMode,
      riskState,
      drawdown,
      allowed,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log trade executed event
   * 
   * PHASE 7: Supports account-scoped events
   * PHASE 8: Includes executionType metadata (SIMULATED | REAL)
   */
  logTradeExecuted(
    request: TradeRequest,
    result: TradeResult,
    systemMode: string,
    regime?: MarketRegime,
    regimeConfidence?: number,
    accountId?: string
  ): void {
    // PHASE 8: Extract executionType from TradeResult metadata
    const executionType = (result as any).executionType as 'SIMULATED' | 'REAL' | undefined;
    
    const event: TradeExecutedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.TRADE_EXECUTED,
      accountId, // PHASE 7: Account-scoped
      strategyId: request.strategy,
      systemMode,
      regime: regime?.toString(),
      regimeConfidence,
      executionType, // PHASE 8: Execution type metadata
      pair: request.pair,
      action: request.action,
      amount: request.amount,
      price: request.price,
      orderId: result.orderId,
      executedValue: result.executedValue || request.estimatedValue,
      reason: 'Trade executed successfully',
      metadata: {
        pnl: result.pnl,
        slippage: (result as any).slippage || 0, // PHASE 8: Include slippage from simulated execution
        fees: (result as any).fees || 0, // PHASE 8: Include fees from simulated execution
        executionPrice: result.executionPrice,
        quantity: result.quantity
      }
    };

    this.eventLog.append(event);
  }

  /**
   * Log trade blocked event
   * 
   * PHASE 7: Supports account-scoped events
   */
  logTradeBlocked(
    request: TradeRequest,
    blockingLayer: 'CAPITAL' | 'REGIME' | 'PERMISSION' | 'RISK',
    reason: string,
    systemMode: string,
    regime?: MarketRegime,
    regimeConfidence?: number,
    accountId?: string
  ): void {
    const event: TradeBlockedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.TRADE_BLOCKED,
      accountId, // PHASE 7: Account-scoped
      strategyId: request.strategy,
      systemMode,
      regime: regime?.toString(),
      regimeConfidence,
      pair: request.pair,
      blockingLayer,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log system mode change
   */
  logSystemModeChange(
    previousMode: string,
    newMode: string,
    reason: string
  ): void {
    const event: SystemModeChangeEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.SYSTEM_MODE_CHANGE,
      previousMode,
      newMode,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log strategy state change
   */
  logStrategyStateChange(
    strategyId: string,
    previousState: string,
    newState: string,
    reason: string,
    systemMode: string
  ): void {
    const event: StrategyStateChangeEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.STRATEGY_STATE_CHANGE,
      strategyId,
      systemMode,
      previousState,
      newState,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * Log regime detection
   */
  logRegimeDetected(
    symbol: string,
    regime: MarketRegime,
    confidence: number,
    metrics: {
      realizedVolatility: number;
      volatilityExpansion: number;
      trendStrength: number;
      correlationStability: number;
    },
    systemMode: string
  ): void {
    const event: RegimeDetectedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.REGIME_DETECTED,
      systemMode,
      symbol,
      regime: regime.toString(),
      confidence,
      metrics,
      reason: `Regime detected: ${regime} (${(confidence * 100).toFixed(0)}% confidence)`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget check
   */
  logRiskBudgetCheck(
    accountId: string,
    strategyId: string,
    requestedRiskPct: number,
    allocatedRiskPct: number,
    effectiveRiskPct: number,
    allowed: boolean,
    reason: string,
    systemMode: string
  ): void {
    const event: RiskBudgetCheckEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_CHECK,
      accountId,
      strategyId,
      systemMode,
      requestedRiskPct,
      allocatedRiskPct,
      effectiveRiskPct,
      allowed,
      reason
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget regime scaling
   */
  logRiskBudgetScaling(
    accountId: string,
    regime: string,
    confidence: number,
    previousScalingFactor: number,
    newScalingFactor: number,
    systemMode: string
  ): void {
    const event: RiskBudgetScalingEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_SCALING,
      accountId,
      systemMode,
      regime,
      confidence,
      previousScalingFactor,
      newScalingFactor,
      reason: `Regime scaling: ${regime} (${(confidence * 100).toFixed(0)}% confidence) → ${previousScalingFactor.toFixed(3)} → ${newScalingFactor.toFixed(3)}`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget decay
   */
  logRiskBudgetDecay(
    accountId: string,
    drawdownPct: number,
    penaltyPct: number,
    previousRiskPct: number,
    newRiskPct: number,
    systemMode: string
  ): void {
    const event: RiskBudgetDecayEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_DECAY,
      accountId,
      systemMode,
      drawdownPct,
      penaltyPct,
      previousRiskPct,
      newRiskPct,
      reason: `Drawdown penalty: ${drawdownPct.toFixed(2)}% drawdown → ${penaltyPct.toFixed(2)}% penalty → ${previousRiskPct.toFixed(2)}% → ${newRiskPct.toFixed(2)}% risk`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget recovery
   */
  logRiskBudgetRecovery(
    accountId: string,
    daysSinceDrawdown: number,
    recoveryPct: number,
    previousRiskPct: number,
    newRiskPct: number,
    systemMode: string
  ): void {
    const event: RiskBudgetRecoveryEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_RECOVERY,
      accountId,
      systemMode,
      daysSinceDrawdown,
      recoveryPct,
      previousRiskPct,
      newRiskPct,
      reason: `Recovery: ${daysSinceDrawdown} days → ${recoveryPct.toFixed(2)}% recovery → ${previousRiskPct.toFixed(2)}% → ${newRiskPct.toFixed(2)}% risk`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 8: Log risk budget allocation change
   */
  logRiskBudgetAllocation(
    accountId: string,
    strategyId: string,
    allocatedRiskPct: number,
    weight: number,
    performanceScore: number,
    systemMode: string
  ): void {
    const event: RiskBudgetAllocationEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.RISK_BUDGET_ALLOCATION,
      accountId,
      strategyId,
      systemMode,
      allocatedRiskPct,
      weight,
      performanceScore,
      reason: `Strategy ${strategyId} allocated ${allocatedRiskPct.toFixed(2)}% risk (weight: ${weight.toFixed(3)}, score: ${performanceScore.toFixed(3)})`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 9: Log shadow trade evaluated
   */
  logShadowTradeEvaluated(
    request: TradeRequest,
    simulatedResult: TradeResult,
    observedPriceAtDecision: number,
    observedPriceAtLatency: number,
    trackingId: string,
    systemMode: string,
    accountId?: string
  ): void {
    const event: ShadowTradeEvaluatedEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.SHADOW_TRADE_EVALUATED,
      accountId,
      strategyId: request.strategy,
      pair: request.pair,
      systemMode,
      action: request.action,
      simulatedExecutionPrice: simulatedResult.executionPrice || request.price,
      observedPriceAtDecision,
      observedPriceAtLatency,
      trackingId,
      reason: `Shadow trade evaluated: ${request.strategy} ${request.action} ${request.pair}`
    };

    this.eventLog.append(event);
  }

  /**
   * PHASE 9: Log shadow parity metric
   */
  logShadowParityMetric(
    strategyId: string,
    pair: string,
    trackingId: string,
    metrics: any, // ParityMetrics
    accountId?: string
  ): void {
    const event: ShadowParityMetricEvent = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.SHADOW_PARITY_METRIC,
      accountId,
      strategyId,
      pair,
      trackingId,
      executionPriceError: metrics.executionPriceError,
      executionPriceErrorPct: metrics.executionPriceErrorPct,
      slippageError: metrics.slippageError,
      slippageErrorPct: metrics.slippageErrorPct,
      fillProbabilityMatch: metrics.fillProbabilityMatch,
      latencySensitivity: metrics.latencySensitivity,
      latencySensitivityPct: metrics.latencySensitivityPct,
      pnlDelta: metrics.pnlDelta,
      pnlDeltaPct: metrics.pnlDeltaPct,
      horizonPerformance: metrics.horizonPerformance,
      horizonPerformancePct: metrics.horizonPerformancePct,
      reason: `Parity metrics computed for ${pair} by ${strategyId}`
    };

    this.eventLog.append(event);
  }

  /**
   * VALIDATION: Log confidence gate blocked
   */
  logConfidenceGateBlocked(check: {
    shadowTrades: number;
    requiredShadowTrades: number;
    runtimeDays: number;
    requiredRuntimeDays: number;
    confidenceScore: number;
    requiredConfidenceScore: number;
    allRegimesCovered: boolean;
    noUnsafeCombinations: boolean;
    reason?: string;
  }): void {
    const event: any = {
      eventId: '',
      timestamp: new Date(),
      eventType: EventType.CONFIDENCE_GATE_BLOCKED,
      shadowTrades: check.shadowTrades,
      requiredShadowTrades: check.requiredShadowTrades,
      runtimeDays: check.runtimeDays,
      requiredRuntimeDays: check.requiredRuntimeDays,
      confidenceScore: check.confidenceScore,
      requiredConfidenceScore: check.requiredConfidenceScore,
      allRegimesCovered: check.allRegimesCovered,
      noUnsafeCombinations: check.noUnsafeCombinations,
      blockingReasons: check.reason ? check.reason.split('; ') : [],
      reason: `Confidence gate blocked REAL execution: ${check.reason || 'Requirements not met'}`
    };

    this.eventLog.append(event);
  }
}

